%----------------------------------------------------------------------------
\section{Program felépítése}
%----------------------------------------------------------------------------
	GPU programozásnál a C és C++ programozási nyelvek a legtámogatottabbak; relatíve alacsonyszintûek és jó teljesítmény érhetõ el velük. A szimulátor megírásához mindenképpen objektumorientált nyelvet szerettem volna alkalmazni, így a C++-ra esett a választásom.

	A szimulátorral kapcsolatban kitûzött kezdeti célok nagy vonalakban:
	
	\begin{itemize}
		\item Legyen könnyen karbantartható, az implementált osztályhierarchia legyen nyitott a késõbbi kiegészítésekre és módosításokra.
		\item Minél jobb párhuzamosítási eredmény elérése.
		\item Futtatási paraméterek (konfiguráció) kívülrõl legyenek beállíthatók a felhasználó által, újrafordítás nélkül.
		\item Egy szálon futó referenciamodell biztosítása az eredmények számszerû ellenõrzéséhez.
		\item Grafikus megjelenítés az ellenõrzéshez.
		\item Számítási teljesítmény mérése és kijelzése.
	\end{itemize}

	Megfelelõ grafikai ismeret híján, egy viszonylag egyszerû megjelenítést szerettem volna létrehozni. A rendelkezésre álló segédanyag, illetve ajánlások alapján az \emph{OpenGL}-t (Open Graphics Library) választottam.

	Az egyszerûbb bemutathatóság érdekében feldaraboltam a programom osztályszerkezetét három logikailag egybefüggõ csoportra. Az osztályokat tartalmazó ábrákon az tagváltozók és a tagfüggvények csak részlegesen vannak feltüntetve, valamint az átláthatóság érdekében a függvény argumentumlisták üresek. A fejezetnek nem célja, hogy részletességében felérjen egy teljes értékû dokumentációval.

	Az oszályokat és struktúrákat egy \verb+NBody+ prefixummal láttam el, valamint az osztály tagváltozók nevében használtam kiegészítõ jelöléseket:
	
	\begin{itemize}
		\item \verb+m+ - tagváltozó (member)
		\item \verb+p+ - mutató (pointer)
		\item \verb+h+ - host
		\item \verb+d+ - eszköz (device)
	\end{itemize}

	Így például az \verb+mpd_position+ egy, az eszköz memóriájában allokált címre mutató tagváltozó pointer.

	Az osztályokból rendszerint egy-egy példány létezik a szimulátor futása során, így gyakran szimplán csak osztálynévvel fogok hivatkozni rájuk, a tényleges objektum megnevezése nélkül.
	
	%----------------------------------------------------------------------------
	\subsection{Konfigurációs paraméterek}
	%----------------------------------------------------------------------------
		Az \figref{Impl_Properties} ábrán látható diagram mutatja a csoportnak a felépítését. Fõleg enumerációkat, valamint egy struktúrát tartalmaz, melynek feladata a felhasználó által beállított paraméterek tárolása. A paramétereket a program futtatásakor adhatja meg a felhasználó kulcs-érték ($key=value$) formában.
		
		\begin{figure}[!ht]
		\centering
		\includegraphics[width=150mm, keepaspectratio]{figures/Implementation/Impl_Properties.png}
		\caption{Futtatási beállításokat tároló struktúra és kiegészítõ enumerációi}
		\label{fig:Impl_Properties}
		\end{figure}

		A rendszerben található többi osztály rendelkezik \verb+NBodyProperties+ típusú tagváltozóval, ami egy közös, a main függvény elején feltöltött objektumra mutat. A struktúra egyes attribútumait és szerepüket az \tabref{Impl_propertiesTable} táblázat ismerteti röviden.

		% Table generated by Excel2LaTeX from sheet 'NBodyProperties'
		\begin{table}[htbp]
		  \centering
		  \caption{Beállítható paraméterek és rövid bemutatásuk}
			\begin{tabular}{|l|p{93mm}|}
			\hline
			Attribútum & Leírás \\
			\hline \hline
			mode  & Program felhasználás szempontjából a legalapvetõbb beállítás, mellyel megadható, hogy grafikus kijelzést vagy teljesítménymérést szeretnénk végezni a futtatás során.  \\
			\hline
			algorithm & Az algoritmus típusát választhatjuk ki. Jelenleg csak ALL\_PAIRS opció a támogatott, mely az \sectref{nbody_direct} fejezetben bemutatott direkt módszernek felel meg. \\
			\hline
			massInit & Véletlenszerû vagy azonos tömegû testek generálása. \\
			\hline
			formation & A testek kezdeti pozícióját befolyásoló beállítás, mellyel megadható, hogy az összes test a origó körül vagy pedig szétszórtan, csoportokban helyezkedjenek el. \\
			\hline
			dimension & A testek pozíciójának harmadik koordinátáját lehet, vele fixen kinullázni. \\
			\hline
			technology & Egy másik fontos beállítás, mellyel megadhatjuk az alkalmazandó párhuzamosítási technikát. Lehet választani a tisztán C++ alapú vagy SSE, AVX vektorutasításokat alkalmazó, illetve GPU-s megvalósítás között. \\
			\hline
			useOpenMP & OpenMP alapú többszálúsítás alkalmazása CPU-s algoritmusok esetén. \\
			\hline
			performanceRuns & Teljesítmény mérés során a teljes szimuláció lefuttatásának száma. A futási eredmény ennek függvényében kerül kiátlagolásra. \\
			\hline
			numBody & A testek száma. SSE és AVX használata mellett a 4, illetve 8-al osztható darabszám a preferált. \\
			\hline
			seed  & A testek kezdeti paramétereit megadó véletlen szám generátor magja. Azonos konfiguráció használata reprodukálhatóvá teszi a szimulációkat. \\
			\hline
			massScale & A testek tömegét befolyásoló tényezõ. Ekörül a szám körül kerülnek az értékek generálásra. \\
			\hline
			positionScale & A testek kezdeti pozícióját befolyásoló tényezõ. Ekörül a szám körül kerülnek az értékek generálásra. \\
			\hline
			velocityScale & A testek kezdeti sebességét befolyásoló tényezõ. Ekörül a szám körül kerülnek az értékek generálásra. \\
			%\hline
			%initVelocityFactor & Nem releváns. Másodlagos skálázás a testek kezdeti sebességére. \\
			\hline
			startTime & Szimuláció kezdés idõpontja. Jelenleg nem sok mindent befolyásol. Tipikusan 0 értékû. \\
			\hline
			stepTime & Szimulációs lépésköz. Új pozíció, sebességértékek meghatározásánál van fontos szerepe. \\
			\hline
			endTime & A szimuláció végidõpontja. A startTime és a stepTime segítségével kalkulálódik ki a szimulációs iterációk száma. \\
			\hline
			currentTime & A jelenlegi szimulációs idõt tartalmazó változó. \\
			%\hline
			%allowLogger & Nem releváns. Tervben volt, a futási eredményeket egy szöveges log fájlba kiíró osztály létrehozása. Ezzel a paraméterrel lehetett volna ki-bekapcsolni. \\
			\hline
			useReferenceModel & Egy szálon futó referencia algoritmus használatát és a testek pozícióértékeinek összehasonlítását lehet vele bekapcsolni. \\
			\hline
			GRAV\_CONSTANT & Gravitációs konstans. \\
			\hline
			EPS2  & $\varepsilon^2$ - softening factor. \\
			\hline
			VELOCITY\_DAMPENING & Integrálás során, a sebességértékek számításakor bejövõ szorzótényezõ. \\
			\hline
			\end{tabular}%
		  \label{tab:Impl_propertiesTable}%
		\end{table}%

	%----------------------------------------------------------------------------
	\subsection{Algoritmusok}
	%----------------------------------------------------------------------------
		Az algoritmusokhoz megvalósító osztályokat és a köztük lévõ kapcsolatokat a \figref{Impl_Algorithm} ábra szemlélteti.

		\begin{figure}[!ht]
		\centering
		\includegraphics[width=150mm, keepaspectratio]{figures/Implementation/Impl_Algorithm.png}
		\caption{Az algoritmusokhoz kapcsolódó osztályok}
		\label{fig:Impl_Algorithm}
		\end{figure}

		Strategy tervezési mintát (design pattern) alkalmaztam, hogy az egyes algoritmusok cserélhetõk legyenek a program többi részének befolyásolása nélkül. Az algoritmust példányosító osztály számára közömbösek a megvalósítás részletei.
		%----------------------------------------------------------------------------
		\subsubsection{NBodyAlgorithm}
		%----------------------------------------------------------------------------
			Egy absztrakt õsosztály, mely egy egységes interfész szerepét tölti be. A program szimulációért felelõs osztálya egy ilyen típusú pointerrel rendelkezik, ami ténylegesen egy tagfüggvény implementációkat már tartalmazó, leszármazott osztály egy objektumára mutat.
			
			Az \verb+advance+ metódus meghívásával minden testre kiszámításra kerülnek az új gyorsulás értékek, valamint ezek függvényében frissül a pozíció- és a sebességvektor is. A program futása során ebben a metódusban tölti el a legtöbb idõt.
			
			Az \verb+init+ és a \verb+destroy+ tagfüggvények az eszköz memóriaterületének allokációját, valamint felszabadítását végzik.
		
		%----------------------------------------------------------------------------
		\subsubsection{NBodyAlgorithmCPU}
		%----------------------------------------------------------------------------
			Szintén egy absztrakt osztály, melynek leglényegesebb feladata, hogy a testpárok közötti gyorsulás értékeket kiszámító \verb+calculateAcceleration+ tagfüggvények definícióit tartalmazza. Két test közötti interakció mértékének kiszámítása ugyanis teljes egészében algoritmus független.
			
			Az \figref{Impl_Algorithm} ábrán csak egy metódust jelöltem meg, azonban ténylegesen 6 \verb+calculateAcceleration+ került megvalósításra. Ebbõl 3 a teljesítményméréshez, 3 pedig a grafikus kijelzéshez használatos; 1-1 sor plusz kódot (szomszédok számának meghatározása) és argumentumot leszámítva páronként azonosak. A három tagfüggvénybõl kettõ használ speciális párhuzamosítási technikákat, a harmadik natív C++ referenciafüggvény. Sima C++ megvalósítás esetén 1, SSE esetén egyszerre $4$, AVX esetén pedig egyszerre 8 gyorsulás érték kerül kiszámításra.
			
			A különbözõ N-test algoritmus implementációk ebbõl az osztályból származnak le. A következõ lépés lehetne egy \verb+NBodyAlgorithmCPUBarnesHut+ osztály megvalósítása például.

		%----------------------------------------------------------------------------
		\subsubsection{NBodyAlgorithmCPUAllPairs}
		%----------------------------------------------------------------------------
			Az \sectref{nbody_direct} fejezetben bemutatott direkt módszert megvalósító osztály. A futtatási beállításoktól függõen, ciklikusan meg kell hívnia a megfelelõ, õsosztályban implementált \verb+calculateAcceleration+ metódust. Miután minden testre kiszámolta az új gyorsulás értékeket, jön az integrálás, vagyis a pozíció- és sebességértékek frissítése (\verb+updateBodies+ tagfüggvény).

		%----------------------------------------------------------------------------
		\subsubsection{NBodyAlgorithmGPU}
		%----------------------------------------------------------------------------
			Hasonló feladatot tölt be, mint a CPU-s társa, csak kiegészül GPU-s futtatáshoz szükséges pointerekkel és metódusokkal. Az algoritmus példányosításakor lefutó \verb+init+ metódus fogja az eszköz memóriájában a szükséges területeket lefoglalni, valamint a kezdeti értékeket bemásolni. Lényeges eltérés a CPU-s megvalósítástól, hogy a jobb teljesítmény elérés és optimálisabb memóriahasznát érdekében tömbökbe ,,kicsomagolt'' testekkel dolgozik, a \figref{Impl_System} ábrán látható a \verb+Body+ nevû struktúra helyett. A \verb+packBodies+, és az \verb+unpackBodies+ tagfüggvények végzik az adatok másolgatását egyik formából a másikba. Ezeknek csak grafikus megjelenítés esetén van szerepük.

		%----------------------------------------------------------------------------
		\subsubsection{NBodyAlgorithmGPUAllPairs}
		%----------------------------------------------------------------------------
			Szintén a direkt N-test algoritmust valósítja meg az osztály, csak most GPU a céleszköz. Bizonyos függvényeket szerettem volna az õsosztályába beágyazni, de a fordító valamilyen oknál fogva ezt nem szerette, így itt került minden kernel és hozzátartozó segédfüggvény implementálásra. Az \verb+integrateKernel+ egyszeri meghívásával történik egy szimulációs iteráció lefuttatása.
		
	%----------------------------------------------------------------------------
	\subsection{Rendszer}
	%----------------------------------------------------------------------------
		Ez az osztálycsoport alkotja a szimulátor központi részét. Az osztályok közötti kapcsolatot modellezi a \figref{Impl_System} ábra.

		\begin{figure}[!ht]
		\centering
		\includegraphics[width=150mm, keepaspectratio]{figures/Implementation/Impl_System.png}
		\caption{ A szimulátor központi osztályai}
		\label{fig:Impl_System}
		\end{figure}

		%----------------------------------------------------------------------------
		\subsubsection{Body}
		%----------------------------------------------------------------------------
			Konténerstruktúra a testek tulajdonságainak tárolására. Elõször a memóriában való adattárolás szempontjából kedvezõbb megoldást szerettem volna alkalmazni: elhelyezni a különbözõ testek azonos jellegû tulajdonságait egyszerû tömbökben (SoA - \emph{Structure of Arrays}). A jobb kezelhetõség és átláthatóság érdekében, azonban logikailag szétválasztott struktúra mellett döntöttem (AoS - \emph{Array of Structures}).

			Tartalmazza a test tömegét, aktuális pozíció-, sebesség- és gyorsulásvektorát.

		%----------------------------------------------------------------------------
		\subsubsection{NBodySystem}
		%----------------------------------------------------------------------------
			A testeket tároló vektoron kívül számos pointerrel rendelkezik a program többi részére. Az \verb+init+ metódus meghívásával kerülnek legenerálásra a testek kezdeti paraméterei, ügyelve arra, hogy két test ne legyen ,,túl közel'' egymáshoz. Ennek akkor lenne jelentõsége, ha nem használnánk a $\varepsilon$ tényezõt (lásd \eqref{NBody_accEq} képlet), ami numerikus szingularitást hivatott megelõzni.
		
			A \verb+setAlgorithm+ a futtatási konfigurációban (\verb+mp_properties+) beállítottak alapján kiválasztja és példányosítja a megfelelõ algoritmust.
		
			Az \verb+advance+ tagfüggvény hívja meg az algoritmusban megvalósított, megegyezõ nevû \verb+advance+ tagfüggvényt. Ezt követõen lépteti az jelenlegi idõt, a megadott szimulációs lépésközzel.
			
			Az \verb+integrate+ metódus meghívásával indul el a szimuláció (lényegében egy ciklus, melynek a leállási feltétele, hogy a jelenleg eltelt idõ kisebb, mint a leállási idõ).
		
			Az \verb+integrateFlat+ egy próbálkozás volt a teljesítmény javítására, a karbantarthatóbb osztályhierarchia feláldozásával. A függvényhívások rendszere és az osztályok megszüntetésével egy ,,spagetti-kód''-szerû függvény. Errõl és ennek eredményérõl a késõbbiekben még szó lesz.
		
			Opcionálisan példányosítható egy egy szálon futó natív C++-os referencia algoritmus és egy hozzátartozó \verb+NBodyProperties+. Ha be van kapcsolva ez az ellenõrzés, akkor ennek is lefut az advance tagfüggvénye és összehasonlításra kerülnek az eredmények.

		%----------------------------------------------------------------------------
		\subsubsection{NBodySystemFlat}
		%----------------------------------------------------------------------------
			Szintén egy próbálkozás volt a teljesítmény növelésére. A \verb+Body+ osztály használata és AoS megoldás helyett, egyszerû, dinamikusan allokált tömböket hoztam létre. Látható, hogy nem tartalmaz referenciát semmilyen algoritmusra, ugyanis az \verb+integrate+ függvényben valósítottam meg a számításokat. A teljesítménynövekedés számottevõ volt, melyrõl majd a késõbbiekben beszámolok.
		
			Ez az osztály csak a programkód módosításával példányosítható és használható.

		%----------------------------------------------------------------------------
		\subsubsection{NBodyInitializator}
		%----------------------------------------------------------------------------
			Feladata a testek kezdeti attribútumait feltölteni véletlenszerûen generált, normális eloszlású értékekkel. A testeket az \verb+NBodyProperties+ \verb+formation+ mezõjében beállított érték alapján helyezi el. Lehetnek az origó körül szétszórtan vagy véletlenszerûen létrehozott pontok környékén, nagyjából egyenletesen szétosztva.
		
			A megfelelõ algoritmust is ez az osztály példányosítja és inicializálja

			\towrite{Képeket lehetne ide linkelni, a függelékbõl vagy valahonnan}

		%----------------------------------------------------------------------------
		\subsubsection{NBodyRenderer}
		%----------------------------------------------------------------------------
			Az osztály teljesen statikus, példány nem hozható létre. Erre a \emph{callback} függvények használata miatt volt szükség, melyeket az OpenGL használ, miután meghívódott a vezérlõ ciklusát tartalmazó függvénye. 
		
			Az \verb+initGL+ tagfüggvény állítja be a legfontosabb paremétereket, pl.: ablak méret, háttérszín, élsimítás bekapcsolása.
		
			A \verb+renderCallback+ az, ami meghívja a példányosított \verb+NBodySystem+ \verb+advance+ metódusát és méri az eltelt szimulációs idõt. Miután kiszámításra kerültek az új pozícióértékek, meghívja a \verb+renderSystem+ nevû függvényt, mely kirajzoltatja az egyes pontokat a képernyõre. Ez használja fel a \verb+getColor+ nevû segédfüggvényt, mely minden testnek beállítja a színét, a közelében elhelyezkedõ testek száma alapján. Minél több ,,szomszédja'' van annál világosabb a színe.
		
			A \verb+main+ függvény az amely ezt példányosíthatja. Grafikus kijelzésnél nincs idõ- és teljesítménymérés.

		%----------------------------------------------------------------------------
		\subsubsection{NBodyUtility}
		%----------------------------------------------------------------------------
			Kiegészítõ, segédosztály szerepet tölt be. Feladatai a felhasználó beállítások értelmezése (\verb+commandLineParse+ függvény), az idõ- és teljesítménymérés, valamint a hibaszámítás.
		
			Az program felállása után a \verb+*Stopwatch+ nevû függvényi segítségével méri le a szimuláció hosszát. Kiszámolja, hogy összesen hány erõt kellett kiszámolni, hány lebegõpontos operációt végzett el összesen a program és ezek függvényében írja ki a futási teljesítményt.
		
			Amennyiben referenciamodellt használunk, minden iteráció után meghívódik a \verb+calculateError+ metódus, ami minden testnek összehasonlítja a pozícióját és jelzi azonnal, ha lényeges értékbeli eltérést tapasztalt.

		%----------------------------------------------------------------------------
		\subsubsection{A main függvény}
		%----------------------------------------------------------------------------
			Itt kerül példányosításra minden központi osztály, melyek aztán \verb+shared pointer+-rel hivatkoznak egymásra.
		
			Ha grafikus kijelzés be lett állítva, akkor az \verb+NBodyRenderer+ \verb+renderMainLoop+ statikus tagfüggvénye veszi át a vezérlést. Teljesítménymérés üzemmód esetén pedig az \verb+NBodySystem+ \verb+integrate+ metódusa lesz végzi a szimulációt.

			A \figref{Impl_ProgramInitSeq} és a \figref{Impl_SimulationSeq} ábra a szimulátor mûködését mutatja be. Az egyes fázisok egymást követik, de külön-külön jobban ábrázolhatók.

			\begin{figure}[!ht]
			\centering
			\includegraphics[width=150mm, keepaspectratio]{figures/Implementation/Impl_ProgramInitSeq.png}
			\caption{A program inicializációs fázisa}
			\label{fig:Impl_ProgramInitSeq}
			\end{figure}
			
			\begin{figure}[!ht]
			\centering
			\includegraphics[width=150mm, keepaspectratio]{figures/Implementation/Impl_SimulationSeq.png}
			\caption{A program szimulációs fázisa}
			\label{fig:Impl_SimulationSeq}
			\end{figure}
